package it.unipr.informatica.example01;

public class Example01 {
	private Object mutex = new Object();
	
	// scegliamo se metterlo privato o pubblico
	// di solito degli attributi mettiamo private, hanno senso public se hanno scopo identificato
	// es.: qualcuno da fuori vuole chiamare go()
	public void go() {
		Runnable runnable = new Runnable() {
		
		@Override
		public void run() {
			System.out.println("Started thread");
			
			try {
				// in questo punto, il thread viene messo in stato 'bloccato' per almeno 2sec
				// almeno 2 secondi vengono garantiti
				Thread.sleep(2000);
				// InterruptedException per una singola eccezzione
			} catch (Throwable e) {
				// non facciamo niente
			}
			
			// attenzione a sincronizzare sul mutex
			synchronized (mutex) {
				notifyAll();
			}
			
			System.out.println("Terminated thread");
		}
		};
		
		Thread notifier = new Thread(runnable);
		
		runnable = new Runnable() {
			@Override
			public void run() {
				System.out.println("Waiter started");
				
				System.out.println("Waiter terminated");
			}
		};
		
		Thread waiter = new Thread(runnable);
		
		notifier.start();
		
		waiter.start();
	}
	
	// static non ha accesso agli attributi diversi da static
	public static void main(String[] args) {
		// definito nell'altro file possiamo creare un Notifier
		new Example01().go();
	}
	
	//NOTA SULLA NOMENCLATURA
	//tenere a mente che le classi avranno sempre nome con la Maiuscola
	//i metodi sono sempre in minuscolo

	//lo stato di Esempio01 è condiviso per la Notifier 
	//private class Notifier extends Thread {
		// è buona norma scrivere @Override perché esiste già un metodo col nome run()
		// a noi serve ridefinirlo e quindi lo scriviamo
}
