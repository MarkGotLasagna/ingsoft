package it.unipr.informatica.example01;

public class Example01 {
	private Object mutex = new Object();
	
	// scegliamo se metterlo privato o pubblico
	// di solito degli attributi mettiamo private, hanno senso public se hanno scopo identificato
	// es.: qualcuno da fuori vuole chiamare go()
	public void go() {
		Thread notifier = new Thread(() -> {
			doNotify();
		});
		
		Thread waiter = new Thread(() -> {
			doWait();
		});
		
		notifier.start();
		
		waiter.start();
	}
	
	//NOTA SULLA NOMENCLATURA
	//tenere a mente che le classi avranno sempre nome con la Maiuscola
	//i metodi sono sempre in minuscolo

	//lo stato di Esempio01 è condiviso per la Notifier 
	//private class Notifier extends Thread {
		// è buona norma scrivere @Override perché esiste già un metodo col nome run()
		// a noi serve ridefinirlo e quindi lo scriviamo
	private void doNotify() {
		System.out.println("Notifier started");
		
		// gestiamo l'interrupted exception
		try {
			// in questo punto, il thread viene messo in stato 'bloccato' per almeno 2sec
			// almeno 2 secondi vengono garantiti
			Thread.sleep(5000);
			// InterruptedException per una singola eccezzione
		} catch (Throwable e) {
			// non facciamo niente
		}
		
		// attenzione a sincronizzare sul mutex!
		// 
		synchronized (mutex) {
			mutex.notifyAll();
		}
		
		System.out.println("Notifier terminated");
	}

	
	private void doWait() {
			System.out.println("Waiter started");
			
			synchronized (mutex) {
				try {
					mutex.wait();
				} catch (Throwable e) {
					// TODO: handle exception
				}
			}
			
			System.out.println("Waiter terminated");
	}
	
	// static non ha accesso agli attributi diversi da static
	public static void main(String[] args) {
		// definito nell'altro file possiamo creare un Notifier
		new Example01().go();
	}
}
